---
title: "1. Коллекции"
---

Примеры из лекций и входной код для выполнения заданий находится в репозитории [https://github.com/AltmanEA/edu-collection](https://github.com/AltmanEA/edu-collection).

В задании требуется самостоятельно изучить отдельные элементы библиотеки коллекций. Для этого рекомендуется в среде набрать название элемента и с помощью сочетания клавиш ```Ctrl-B``` открыть исходный код этого элемента. В исходном коде в комментариях приведено описание этого элемента, из которого потом генерируется документация. Этого описания должно быть достаточно для понимания того, что и для чего делает этот элемент.

Если описания в документации не достаточно то можно попробовать разобраться с исходным кодом, который доступен для библиотечных функций и классов. Если и исходного кода оказалось недостаточно для понимания какого-либо элемента библиотеки то можно попробовать найти информацию в сети интернет. Однако её следует проверить с помощью экспериментов с кодом, поскольку в интернете встречается много устаревшей или некорректной информации.

1. Операции с коллекциями
   
   1. Изучите функцию ```mapIndexed``` и создайте с её помощью коллекцию ```studentIndexes``` c индексами коллекции ```students```.
   2. Изучите функцию ```zip``` и создайте с её помощью из коллекций ```students``` и ```studentIndexes``` коллекцию ```studentWithIndexes``` из ```Pair<index, student>```.
   3. Изучите функцию ```joinToString``` и создайте с её помощью из коллекции ```studentWithIndexes``` строку ```studentsString``` содержащую перечисленные через запятую пары коллекции. Элементы каждой пары должны выводиться через дефис.
   
    После вывода на печать результатов предыдущих пунктов должно получиться примерно следующее:
    <pre><code> [0, 1, 2, 3, 4, 5, 6]
    [(0, Sheldon), (1, Leonard), (2, Howard), (3, Raj), (4, Penny), (5, Amy), (6, Bernadette)]
    0  - Sheldon, 1  - Leonard, 2  - Howard, 3  - Raj, 4  - Penny, 5  - Amy, 6  - Bernadette</pre></code>

2. Виды коллекций
   
   1. Изучите исходный код функций ```maxBy``` и ```count``` класса ```Iterable```. На их основе создайте функцию ```fun <T> Iterable<T>.countBy(value: Int, selector: (T) -> Int): Int```, которая бы подсчитывала число элементов коллекции для которых значение ```selector``` было бы равно ```value```.
   2. Из коллекции ```grades``` с использованием функции ```mapTo``` создайте множество (Set) оценок, которые получили студенты.
   3. Изучите функцию ```associate``` класса ```Iterable```. С помощью нее и созданной в первом пункте функции ```countBy``` создайте карту (Map), ключом в которой является оценка, а значение – количество студентов, которые получили эту оценку.
   4. Используя подсказку среды замените функцию ```associate``` на ```associateWith```. Изучите функцию ```associateWith```.
   
    После вывода на печать результатов последнего пункта должно получиться примерно следующее:
    <pre><code> {3=1, 4=2, 5=1}</pre></code>

3. Реализация коллекций
   
   1. Изучите описание интерфейса ```Deque```. Разберитесь, как с помощью него можно реализовать стек LIFO, в частности, выполнять операции «поместить в стек» и «взять из стека».
   2. Создайте коллекцию тип ```Deque``` на основе ```LinkedList``` поместив туда первых трех студентов (используйте при этом функцию ```subList```).
   3. Выполните следующие действия над стеком, распечатывая состояние стека до и после операции и результат самой операции:
      1. Поместите в стек студента с индексом 4.
      2. Возьмите элемент с вершины стека.
   4. Изучите функцию ```merge``` класса ```TreeMap```. Создайте с помощью этой функции карту в которой является оценка, а значение – список студентов через запятую, которые получили эту оценку. Выведите результат на печать.
   
    Результат выполнения последних пунктов должен быть примерно такой:
    <pre><code> [Sheldon, Leonard, Howard]
    kotlin.Unit
    [Penny, Sheldon, Leonard, Howard]
    Penny
    [Sheldon, Leonard, Howard]

    {3=Raj, 4=Leonard, Howard, 5=Sheldon}</pre></code>

